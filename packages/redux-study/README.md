## React 状态管理 学习





- redux
- react-redux
- `@reduxjs/toolkit`
- MobX
- Zustand





## 常见的状态管理库

### 1. Redux

**特点**：
- 基于 Flux 架构的状态管理库。
- 使用单一的全局状态树（store）。
- 状态是不可变的，每次更新都会创建新的状态。
- 使用纯函数（reducers）来处理状态更新。

**优点**：
- 强大的社区支持和丰富的生态系统。
- 适用于大型应用，易于调试和测试。
- 状态管理清晰，易于追踪状态变化。

**缺点**：
- 需要编写大量的样板代码。
- 学习曲线较陡，尤其是对于初学者。
- 处理异步操作需要使用中间件（如 `redux-thunk` 或 `redux-saga`）。

**适用场景**：
- 大型应用，需要复杂的状态管理。
- 需要严格的状态管理和调试。

### 2. React-Redux

**特点**：
- 是 Redux 的官方 React 绑定库。
- 提供了 `Provider` 组件和 `connect` 高阶组件（HOC）来连接 React 组件和 Redux store。
- 使用 `useSelector` 和 `useDispatch` hooks 来简化状态和操作的访问。

**优点**：
- 与 Redux 无缝集成，提供了高效的 React 绑定。
- 支持性能优化，如 `memo` 和 `useCallback`。

**缺点**：
- 仍然需要编写一些样板代码。
- 对于简单的状态管理，可能会显得过于复杂。

**适用场景**：
- 使用 Redux 的 React 应用。
- 需要高效的 React 绑定和性能优化。

### 3. @reduxjs/toolkit

**特点**：
- 是 Redux 的官方工具包，旨在简化 Redux 的使用。
- 内置了 `createSlice`、`createAsyncThunk` 等工具，减少了样板代码。
- 使用了 `Immer` 库来简化不可变状态的管理。

**优点**：
- 显著减少了样板代码，提高了开发效率。
- 内置了处理异步操作的工具（如 `createAsyncThunk`）。
- 推广了 Redux 的最佳实践。

**缺点**：
- 仍然需要理解 Redux 的核心概念。
- 对于简单的状态管理，可能会显得过于复杂。

**适用场景**：
- 使用 Redux 的现代应用。
- 需要简化 Redux 的使用和推广最佳实践。

### 4. MobX

**特点**：
- 基于观察者模式的状态管理库，强调响应式编程。
- 状态是可变的，状态更新直观。
- 使用 `observable`、`action` 和 `computed` 来管理状态。

**优点**：
- 简单易用，状态更新直观。
- 性能良好，自动优化组件渲染。
- 支持类组件和函数组件。

**缺点**：
- 学习曲线较陡，需要理解响应式编程的概念。
- 状态管理不如 Redux 清晰，可能难以追踪状态变化。

**适用场景**：
- 需要响应式状态管理的应用。
- 需要简单直观的状态更新。

### 5. Zustand

**特点**：
- 轻量级状态管理库，基于 hooks。
- 使用 `create` 函数来创建 store，状态更新简单。
- 支持中间件和异步操作。

**优点**：
- 简单易用，几乎没有样板代码。
- 性能良好，自动优化组件渲染。
- 支持 TypeScript，类型安全。

**缺点**：
- 社区支持和生态系统不如 Redux 和 MobX。
- 功能相对较少，适合小型应用。

**适用场景**：
- 需要轻量级状态管理的应用。
- 需要简单直观的状态更新。



### 6. React Context API

**特点**：

- React 自带的状态管理工具，无需安装额外的库。
- 使用 `createContext` 创建上下文，使用 `Provider` 提供状态，使用 `useContext` 访问状态。
- 适用于简单的状态共享，不适合复杂的状态管理。

**优点**：

- 无需安装额外的库，简单易用。
- 适用于小型应用或不需要复杂状态管理的场景。

**缺点**：

- 不适合复杂的状态管理，容易导致组件重新渲染。
- 没有内置的工具来处理异步操作或复杂的状态更新。

**适用场景**：

- 小型应用或不需要复杂状态管理的场景。
- 简单的状态共享，如主题、语言等。



### 对比总结

| 特性/库          | Redux                        | React-Redux                  | @reduxjs/toolkit      | MobX           | Zustand        | React Context API |
| ---------------- | ---------------------------- | ---------------------------- | --------------------- | -------------- | -------------- | ----------------- |
| **状态管理模型** | 单一全局状态树               | 单一全局状态树               | 单一全局状态树        | 响应式状态     | 单一全局状态树 | 上下文状态        |
| **状态更新**     | 不可变，纯函数               | 不可变，纯函数               | 不可变，Immer         | 可变，响应式   | 可变，简单     | 可变，简单        |
| **异步操作**     | 需要中间件（如 redux-thunk） | 需要中间件（如 redux-thunk） | 内置 createAsyncThunk | 内置异步操作   | 内置异步操作   | 需要手动处理      |
| **样板代码**     | 多                           | 多                           | 少                    | 少             | 极少           | 少                |
| **学习曲线**     | 陡峭                         | 陡峭                         | 中等                  | 中等           | 简单           | 简单              |
| **社区支持**     | 强大                         | 强大                         | 强大                  | 强大           | 较小           | 内置              |
| **适用场景**     | 大型应用，复杂状态管理       | 使用 Redux 的 React 应用     | 使用 Redux 的现代应用 | 响应式状态管理 | 轻量级状态管理 | 简单状态共享      |

### 总结

- **Redux**：适用于大型应用，需要复杂的状态管理和调试。
- **React-Redux**：适用于使用 Redux 的 React 应用，需要高效的 React 绑定和性能优化。
- **@reduxjs/toolkit**：适用于使用 Redux 的现代应用，需要简化 Redux 的使用和推广最佳实践。
- **MobX**：适用于需要响应式状态管理的应用，需要简单直观的状态更新。
- **Zustand**：适用于需要轻量级状态管理的应用，需要简单直观的状态更新。
- **React Context API**：适用于小型应用或不需要复杂状态管理的场景，简单的状态共享。

选择状态管理库时，应根据项目的具体需求、团队的技术栈和开发经验来决定。对于简单的状态管理，React Context API 或 Zustand 可能是不错的选择；对于复杂的状态管理，Redux 和 `@reduxjs/toolkit` 可能更合适。

## 学习资源

1、redux、react-redux 在  尚硅谷 学习的 ，B站直达：https://www.bilibili.com/video/BV1wy4y1D7JT   资料链接：https://pan.baidu.com/s/15XwT-CdN9PBwZrkQBbU1Kg ，提取码：1hxn



2、`@reduxjs/toolkit` 用 AI 学习的



3、这几个课程都有 redux 相关用法

https://coding.imooc.com/class/chapter/646.html#Anchor 

https://coding.imooc.com/class/chapter/475.html#Anchor

https://coding.imooc.com/class/chapter/602.html#Anchor
